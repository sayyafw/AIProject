1) When calculating avaialable moves, our algorithm iterates through all the currently existsing white pieces and black pieces, for each piece, it first checks if it is on the edge, and if not, it then checks it's surroundings, and making sure it can move to it's adjacent tile; However if the adjacent tile is taken by another piece, it makes sure to check if it can jump over. The time complexity is linear, as for every extra piece on the board, it runs through the checking function once, so O(n). As for space comlexity, all memories can be immediately discarded after calculating the moves for each piece, no matter how many pieces there are it'll always take the same amount of memory, therefore O(1), if we disregarding the memory used to store every piece.

2) For massacre, we implemented A* search, it first iterates through all the currently not-taken black pieces, and find the 2 closest white pieces by iterating through the list of white pieces. then for each of the closest white peices, it first checks each of the 4 possible moves it can make to it's adjacent square, it then checks if the node is visited inside the tree, then calculates the manhattan distance towards it's goal stats, the squares that will remove the black piece, and move the piece accordingly toward that square in the shortest amount of steps possible. 
For Branching factors, each step will grow 4 branches each time, for each adjacent tile (sometimes less than 4, say it's in the corner, then 2, however this is very unlikely to happen).
Maximum Depth for search depth would be the 2 times the length of the board, which is the maximum shortest length a piece needs to move to reach it's goal: from one corner to another. (realistically speaking ~10 steps since if can only start searching for a path if the black piece IS NOT in a corner, effectively reducing board size.)
This algorithm may be modelled after A*, however regrettably it is not a full implementation, and therefore does not return the shortest path all the time, and for reasons such as the following: it tries to remove a black piece one by one, not considering the possible moves to remove 2 black pieces in the shortest amount of move by say, moving to a square where it can "corner" 2 black pieces; for each calculated positions to move to, piece 1 will always move to position 1, and never will it move to position 2, causing often one white piece would walk all the way around in order to consume a black piece instead of a jump and a move.